/*
 * PROPRIETARY INFORMATION.  This software is proprietary to POWDER
 * Development, and is not to be reproduced, transmitted, or disclosed
 * in any way without written permission.
 *
 * Produced by:	Jeff Lait
 *
 *      	POWDER Development
 *
 * NAME:        hamfake.cpp ( POWDER Library, C++ )
 *
 * COMMENTS:
 *	This file implements all the fake ham functions.
 *	It also stores the global state of the hardware.
 */

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <iostream>

using namespace std;

#include "mygba.h"
#include "hamfake.h"
#include "3ds.h"
#include <citro3d.h>

#include "../../gfxengine.h"
#include "../../bmp.h"
#include "../../assert.h"
#include "../../control.h"

// This header is generated by the build process
#include "vshader_shbin.h"

#define CLEAR_COLOR 0x000000FF

// Used to transfer the final rendered display to the framebuffer
#define DISPLAY_TRANSFER_FLAGS \
	(GX_TRANSFER_FLIP_VERT(0) | GX_TRANSFER_OUT_TILED(0) | GX_TRANSFER_RAW_COPY(0) | \
	GX_TRANSFER_IN_FORMAT(GX_TRANSFER_FMT_RGBA8) | GX_TRANSFER_OUT_FORMAT(GX_TRANSFER_FMT_RGB8) | \
	GX_TRANSFER_SCALING(GX_TRANSFER_SCALE_NO))

// Used to convert textures to 3DS tiled format
// Note: vertical flip flag set so 0,0 is top left of texture
#define TEXTURE_TRANSFER_FLAGS \
	(GX_TRANSFER_FLIP_VERT(1) | GX_TRANSFER_OUT_TILED(1) | GX_TRANSFER_RAW_COPY(0) | \
	GX_TRANSFER_IN_FORMAT(GX_TRANSFER_FMT_RGBA8) | GX_TRANSFER_OUT_FORMAT(GX_TRANSFER_FMT_RGBA8) | \
	GX_TRANSFER_SCALING(GX_TRANSFER_SCALE_NO))

static DVLB_s* vshader_dvlb;
static shaderProgram_s program;
static int uLoc_projection;
static C3D_Mtx projection;
static C3D_Mtx projection2;

static C3D_Tex spritesheet_tex,spritesheet_tex2;

u8 *gpusrc;
u8 *gpusrc2;


#define SRAMSIZE 65536

#define KEY_REPEAT_INITIAL 15
#define KEY_REPEAT_AFTER 7

#define MAX_JOY_BUTTON 12

#define TICKS_PER_MSEC (268123.480)
#define TICKS_PER_FRAME ((TICKS_PER_MSEC*1000)/60.5) // we set the timer a little faster than 60 FPS, but the vblank wait will adjust the frame rate to 60 FPS

//
// Global GBA state:
//
C3D_RenderTarget *glbVideoSurface;
C3D_RenderTarget *glbVideoSurface2;
bool		 glbFullScreen = false;
int		 glbScreenWidth = HAM_SCRW;
int		 glbScreenHeight = HAM_SCRH;
int		 glbScaleFactor = 1;
int		 glbScreenFudgeX = 0;
int		 glbScreenFudgeY = 0;

int		 glbStylusX = 0, glbStylusY = 0;
bool		 glbStylusState = false;

bool		 glbJoyState[MAX_JOY_BUTTON];

extern int	glb_newframe; // from gfxengine.c

u64 lastframe = 0;

BUTTONS	 glbJoyToButton[MAX_JOY_BUTTON] =
{
    BUTTON_Y,	
    BUTTON_B,	
    BUTTON_A,	
    BUTTON_X,	
    BUTTON_L,
    BUTTON_R,
    BUTTON_DOWN,
    BUTTON_LEFT,
    BUTTON_UP,
    BUTTON_RIGHT,
    BUTTON_SELECT,
    BUTTON_START
};

u32	 hidButton[MAX_JOY_BUTTON] =
{
    KEY_Y,	
    KEY_B,	
    KEY_A,	
    KEY_X,	
    KEY_L,
    KEY_R,
    KEY_DOWN,
    KEY_LEFT,
    KEY_UP,
    KEY_RIGHT,
    KEY_SELECT,
    KEY_START
};


struct SPRITEDATA
{
  bool 	active;
  int 	x, y;
  u8		data[4*8*8];
};

#define MAX_SPRITES 128


//SPRITEDATA	 *glbSpriteList;
SPRITEDATA	 glbSpriteList[MAX_SPRITES];


// Do we have an extra tileset loaded?
bool		 ham_extratileset = false;


// Background state:
bg_info			ham_bg[7];

bool			glb_isnewframe = 0, glb_isdirty = false;

u8			glb_palette[2048];

// Mode 3 screen - a raw 15bit bitmap.
u16			glb_rawscreen[HAM_SCRW*HAM_SCRH];

// Paletted version of screen which is scaled into final SDL surface
// We use u16 as the high bit selects whether to use sprite or
// global palette
u16			glb_nativescreen[HAM_SCRW*HAM_SCRH];

char			glb_rawSRAM[SRAMSIZE];

int			glb_videomode = -1;


extern void vblFunc();

void
rebuildVideoSystemFromGlobals()
{
  glb_isdirty = true;
}

void
hamfake_setFullScreen(bool fullscreen)
{
  // Pretty straight forward :>
  glbFullScreen = true;
}

bool
hamfake_isFullScreen()
{
  return glbFullScreen;
}

// Updates our glbScreenWidth & glbScreenHeight appropriately.  Finds a scale
// factor that will fit.
void
setResolution(int width, int height)
{
  // Find maximum scale factor that fits.
  if(glbFullScreen) {
	glbScreenWidth = 400;
	glbScreenHeight = 240;
    glbScaleFactor= 1;
  } else {
	glbScreenWidth = 320;
	glbScreenHeight = 240;
    glbScaleFactor= 1;
  }

//  glbScreenWidth = width;
//  glbScreenHeight = height;

  // Calculate our fudge factor...
  glbScreenFudgeX = ((400 - glbScreenWidth) / 2);
  glbScreenFudgeY = 0;

  // Take effect!
//  rebuildVideoSystemFromGlobals();
}

// Draws the given sprite to the native buffer.
void
blitSprite(const SPRITEDATA &sprite)
{
  if (sprite.active)
  {
    // Finally, blit the sprite.
    int		sx, sy, x, y, tx, ty, srcoffset;
    u8		src;

    for (sy = 0; sy < 16; sy++)
    {
      for (sx = 0; sx < 16; sx++)
      {
        x = sprite.x + sx;
        y = sprite.y + sy;
        // Convert to DS coords from GBA
        x += 8;
        y += 16;
        tx = sx >> 3;
        ty = sy >> 3;
        srcoffset = (sx & 7) + tx * 8 * 8 +
                    ty * 2 * 8 * 8 + (sy & 7) * 8;
        src = sprite.data[srcoffset];
        if (src &&
            x >= 0 && x < HAM_SCRW &&
            y >= 0 && y < HAM_SCRH)
        {
          glb_nativescreen[x + y * HAM_SCRW] = src + HAM_SCRW;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------------
void drawTexture( int x, int y, int width, int height) {
//---------------------------------------------------------------------------------

	float left = 0.0f;
	float right = 1.0f;
	float top = 0.0f;
	float bottom = 192.0/256.0;//1.0f;

/*	
	C3D_TexEnv* env = C3D_GetTexEnv(0);
	C3D_TexEnvSrc(env, C3D_Both, GPU_TEXTURE0, 0, 0);
	C3D_TexEnvOp(env, C3D_Both, 0, 0, 0);
	C3D_TexEnvFunc(env, C3D_Both, GPU_REPLACE);
*/

	// Draw a textured quad directly
	C3D_ImmDrawBegin(GPU_TRIANGLES);
		C3D_ImmSendAttrib(x, y, 0.5f, 0.0f); // v0=position
		C3D_ImmSendAttrib( left, top, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x+width, y+height, 0.5f, 0.0f);
		C3D_ImmSendAttrib( right, bottom, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x+width, y, 0.5f, 0.0f);
		C3D_ImmSendAttrib( right, top, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x, y, 0.5f, 0.0f); // v0=position
		C3D_ImmSendAttrib( left, top, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x, y+height, 0.5f, 0.0f);
		C3D_ImmSendAttrib( left, bottom, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x+width, y+height, 0.5f, 0.0f);
		C3D_ImmSendAttrib( right, bottom, 0.0f, 0.0f);


	C3D_ImmDrawEnd();

}


void
scaleScreenFromPaletted(int target)
{

  u16* src = glb_nativescreen;
  u8 *dst;
  if (target == 0) 
	dst=gpusrc;
  else
	dst=gpusrc2;

	int a = 0xff;
	// convert to rgba
	for(int i = 0; i<HAM_SCRW*HAM_SCRH; i++) {
		int r = glb_palette[src[i]*4+3];
		int g = glb_palette[src[i]*4+2];
		int b = glb_palette[src[i]*4+1];

		*dst++ = a;
		*dst++ = b;
		*dst++ = g;
		*dst++ = r;
	}

	// ensure data is in physical ram
	GSPGPU_FlushDataCache(gpusrc, HAM_SCRW*HAM_SCRW*4);

	// Update the uniforms
	if (target == 0) {
		C3D_TexBind(0, &spritesheet_tex);
		C3D_FrameDrawOn(glbVideoSurface);
		C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
		// Convert image to 3DS tiled texture format
		C3D_SafeDisplayTransfer ((u32*)gpusrc, GX_BUFFER_DIM(HAM_SCRW, HAM_SCRW), (u32*)spritesheet_tex.data, GX_BUFFER_DIM(HAM_SCRW, HAM_SCRW), TEXTURE_TRANSFER_FLAGS);
		gspWaitForPPF();
		drawTexture( 0, 0, 400, 240);  
	} else {
		C3D_TexBind(0, &spritesheet_tex2);
		C3D_FrameDrawOn(glbVideoSurface2);
		C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection2);
		// Convert image to 3DS tiled texture format
		C3D_SafeDisplayTransfer ((u32*)gpusrc2, GX_BUFFER_DIM(HAM_SCRW, HAM_SCRW), (u32*)spritesheet_tex2.data, GX_BUFFER_DIM(HAM_SCRW, HAM_SCRW), TEXTURE_TRANSFER_FLAGS);
		gspWaitForPPF();
		drawTexture( 0, 0, 320, 240); 
	}
}

void
scaleScreenFrom15bit(int target)
{

  u16* src = glb_nativescreen;
  u8 *dst;
  if (target == 0) 
	dst=gpusrc;
  else
	dst=gpusrc2;

	int a = 0xff;
	// convert to rgba
	for(int i = 0; i<HAM_SCRW*HAM_SCRH; i++) {
		int r = (src[i]& 31) << 3;
		int g = ((src[i]>> 5) & 31) << 3;
		int b = ((src[i]>> 10) & 31) << 3;

		*dst++ = a;
		*dst++ = b;
		*dst++ = g;
		*dst++ = r;
	}

	// ensure data is in physical ram
	GSPGPU_FlushDataCache(gpusrc, HAM_SCRW*HAM_SCRW*4);

	// Update the uniforms
	if (target == 0) {
		C3D_TexBind(0, &spritesheet_tex);
		C3D_FrameDrawOn(glbVideoSurface);
		C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
		// Convert image to 3DS tiled texture format
		C3D_SafeDisplayTransfer ((u32*)gpusrc, GX_BUFFER_DIM(HAM_SCRW, HAM_SCRW), (u32*)spritesheet_tex.data, GX_BUFFER_DIM(HAM_SCRW, HAM_SCRW), TEXTURE_TRANSFER_FLAGS);
		gspWaitForPPF();
		drawTexture( 0, 0, 400, 240);  
	} else {
		C3D_TexBind(0, &spritesheet_tex2);
		C3D_FrameDrawOn(glbVideoSurface2);
		C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection2);
		// Convert image to 3DS tiled texture format
		C3D_SafeDisplayTransfer ((u32*)gpusrc2, GX_BUFFER_DIM(HAM_SCRW, HAM_SCRW), (u32*)spritesheet_tex2.data, GX_BUFFER_DIM(HAM_SCRW, HAM_SCRW), TEXTURE_TRANSFER_FLAGS);
		gspWaitForPPF();
		drawTexture( 0, 0, 320, 240); 
	}
//	C3D_FrameEnd(0);
}

//---------------------------------------------------------------------------------
static void sceneInit(void) {
//---------------------------------------------------------------------------------
	// Load the vertex shader, create a shader program and bind it
	vshader_dvlb = DVLB_ParseFile((u32*)vshader_shbin, vshader_shbin_size);
	shaderProgramInit(&program);
	shaderProgramSetVsh(&program, &vshader_dvlb->DVLE[0]);
	C3D_BindProgram(&program);

	// Get the location of the uniforms
	uLoc_projection = shaderInstanceGetUniformLocation(program.vertexShader, "projection");

	// Configure attributes for use with the vertex shader
	// Attribute format and element count are ignored in immediate mode
	C3D_AttrInfo* attrInfo = C3D_GetAttrInfo();
	AttrInfo_Init(attrInfo);
	AttrInfo_AddLoader(attrInfo, 0, GPU_FLOAT, 3); // v0=position
	AttrInfo_AddLoader(attrInfo, 1, GPU_FLOAT, 2); // v2=texcoord

	// Compute the projection matrix
	// Note: we're setting top to 240 here so origin is at top left.
	Mtx_OrthoTilt(&projection, 0.0, 400.0, 240.0, 0.0, 0.0, 1.0, true);
	Mtx_OrthoTilt(&projection2, 0.0, 320.0, 240.0, 0.0, 0.0, 1.0, true);

	// Configure buffers
	C3D_BufInfo* bufInfo = C3D_GetBufInfo();
	BufInfo_Init(bufInfo);

	gpusrc = (u8*) linearAlloc(HAM_SCRW*HAM_SCRW*4); // 256*256 because every dim must a a power of 2
	gpusrc2 = (u8*) linearAlloc(HAM_SCRW*HAM_SCRW*4); // 256*256 because every dim must a a power of 2

	// Initialize the top screen render target
	glbVideoSurface = C3D_RenderTargetCreate(240, 400, GPU_RB_RGBA8, GPU_RB_DEPTH24_STENCIL8);
	C3D_RenderTargetSetClear(glbVideoSurface, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
	C3D_RenderTargetSetOutput(glbVideoSurface, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);

	// Initialize the bottom screen render target
	glbVideoSurface2 = C3D_RenderTargetCreate(240, 320, GPU_RB_RGBA8, GPU_RB_DEPTH24_STENCIL8);
	C3D_RenderTargetSetClear(glbVideoSurface2, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
	C3D_RenderTargetSetOutput(glbVideoSurface2, GFX_BOTTOM, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);

	// Load the textures
	C3D_TexInit(&spritesheet_tex, HAM_SCRW, HAM_SCRW, GPU_RGBA8);
	C3D_TexSetFilter(&spritesheet_tex, GPU_LINEAR, GPU_NEAREST);
	C3D_TexBind(0, &spritesheet_tex);

	C3D_TexInit(&spritesheet_tex2, HAM_SCRW, HAM_SCRW, GPU_RGBA8);
	C3D_TexSetFilter(&spritesheet_tex2, GPU_LINEAR, GPU_NEAREST);
	C3D_TexBind(0, &spritesheet_tex2);

	// Configure the first fragment shading substage to just pass through the texture color
	// See https://www.opengl.org/sdk/docs/man2/xhtml/glTexEnv.xml for more insight
	C3D_TexEnv* env = C3D_GetTexEnv(0);
	C3D_TexEnvSrc(env, C3D_Both, GPU_TEXTURE0, 0, 0);
	C3D_TexEnvOp(env, C3D_Both, 0, 0, 0);
	C3D_TexEnvFunc(env, C3D_Both, GPU_REPLACE);

	// Configure depth test to overwrite pixels with the same depth (needed to draw overlapping sprites)
	C3D_DepthTest(true, GPU_GEQUAL, GPU_WRITE_ALL);
}

//---------------------------------------------------------------------------------
static void sceneExit(void) {
//---------------------------------------------------------------------------------

	linearFree(gpusrc);
	linearFree(gpusrc2);
	C3D_RenderTargetDelete(glbVideoSurface);
	C3D_RenderTargetDelete(glbVideoSurface2);
	// Free the shader program
	shaderProgramFree(&program);
	DVLB_Free(vshader_dvlb);
}

void
hamfake_rebuildScreen()
{
  int			i, layer, x, y, tileidx, tx, ty;
  int			offset;
  u64 			sysTicks;
  
  sysTicks = svcGetSystemTick();
//  if (!glb_isdirty && (lastframe + TICKS_PER_FRAME > sysTicks))
  if (lastframe + TICKS_PER_FRAME > sysTicks)
		return;
  if (lastframe + TICKS_PER_FRAME <= sysTicks)
  {
	vblFunc();
	lastframe = sysTicks;
  }

  C3D_FrameBegin(C3D_FRAME_SYNCDRAW);

  
  if (glb_videomode == 3)
  {
   scaleScreenFrom15bit(0);
	C3D_FrameEnd(0);
    return;
  }


  // Clear our video surface.
  memset(glb_nativescreen, 0, HAM_SCRH * HAM_SCRW * sizeof(u16));

  // Blit each layer in turn.
  // Hard coded layer order:
  int		lay_ord[7] = { 1, 2, 3, 4, 5, 6, 0 };

  for (i = 0; i < 7; i++)
  {
    layer = lay_ord[i];


    ty = ham_bg[layer].scrolly / 8;
    ty %= ham_bg[layer].mi->height;
    if (ty < 0)
      ty += ham_bg[layer].mi->height;
    for (y = 0; y < HAM_SCRH / 8; y++)
    {
      tx = ham_bg[layer].scrollx / 8;
      tx %= ham_bg[layer].mi->width;
      if (tx < 0)
        tx += ham_bg[layer].mi->width;
      for (x = 0; x < HAM_SCRW / 8; x++)
      {
        u8		*tile;

        tileidx = ham_bg[layer].mi->tiles[ty * ham_bg[layer].mi->width + tx];

        // Out of bound tiles are ignored.
        if ((tileidx & 1023) < ham_bg[layer].ti->numtiles)
        {
          tile = ham_bg[layer].ti->tiles[tileidx & 1023];

          // Compute offset into native screen
          offset = x * 8 + y * 8 * HAM_SCRW;

          // Figure out any flip flags.
          if (tileidx & (2048 | 1024))
          {
            int	    sx, sy, fx, fy;

            for (sy = 0; sy < 8; sy++)
            {
              if (tileidx & 2048)
                fy = 7 - sy;
              else
                fy = sy;

              for (sx = 0; sx < 8; sx++)
              {
                if (tileidx & 1024)
                  fx = 7 - sx;
                else
                  fx = sx;

                // Write if non-zero
                if (tile[fx + fy * 8])
                  glb_nativescreen[offset] = tile[fx + fy * 8];
                offset++;
              }
              offset += HAM_SCRW - 8;
            }
          }
          else
          {
            int		sx, sy;

            // Straight forward write...
            for (sy = 0; sy < 8; sy++)
            {
              for (sx = 0; sx < 8; sx++)
              {
                if (*tile)
                {
                  glb_nativescreen[offset] = *tile;
                }
                tile++;
                offset++;
              }
              offset += HAM_SCRW - 8;
            }
          }
        }

        tx++;
        if (tx >= ham_bg[layer].mi->width)
          tx -= ham_bg[layer].mi->width;
      }

      ty++;
      if (ty >= ham_bg[layer].mi->height)
        ty -= ham_bg[layer].mi->height;
    }

    // Just before the text layer we draw our sprites
    // This ensures the buttons are under the text.
    if (i == 5)
    {
      int		j;

      // Since we composite on top, we want to do in reverse order of
      // priority.  Hence the backwards loop.
      // The last sprite is the cursor and is done at the very end.
 
     for (j = MAX_SPRITES; j --> 1; )
      {
        blitSprite(glbSpriteList[j]);
      }

    }

    if (i==2)
    {
      scaleScreenFromPaletted(0);
	  // Clear our video surface before filling it with bottom screen data
	  memset(glb_nativescreen, 0, HAM_SCRH * HAM_SCRW * sizeof(u16));
    }

  }

  // Draw the cursor sprite
  blitSprite(glbSpriteList[0]); 
  scaleScreenFromPaletted(1);
	C3D_FrameEnd(0);
}

// Return our internal screen.
u16 *
hamfake_lockScreen()
{
  return glb_nativescreen;//glb_rawscreen;
}

void
hamfake_unlockScreen(u16 *)
{
  glb_isdirty = true;
}

// Deal with our SRAM buffer.
char *
hamfake_writeLockSRAM()
{
  return glb_rawSRAM;
}

void
hamfake_writeUnlockSRAM(char *)
{}

char *
hamfake_readLockSRAM()
{
  return glb_rawSRAM;
}

void
hamfake_readUnlockSRAM(char *)
{}

void
hamfake_endWritingSession()
{
  FILE		*fp;

  fp = fopen("/3ds/Powder/powder.sav", "wb");

  if (!fp)
  {
    cerr << "Failure to open powder.sav for writing!" << endl;
    return;
  }

  fwrite(glb_rawSRAM, SRAMSIZE, 1, fp);

  fclose(fp);
}


int getJoyButton(BUTTONS button)
{
    int		i;

    for (i = 0; i < MAX_JOY_BUTTON; i++)
	if (glbJoyToButton[i] == button)
	    return i;
    return -1;
}

// Called to run our event poll
void
hamfake_pollEvents()
{
// we need here to put  a sleepthread call to handle game paused from home menu
	svcSleepThread(TICKS_PER_MSEC); // 1ms
// Handling home menu event
	if(!aptMainLoop()) hamfake_softReset();

	hidScanInput();
	unsigned int keyHeld = hidKeysHeld();
	int i;
	for (i=0;i<MAX_JOY_BUTTON;i++) {
		if (keyHeld & hidButton[i]) glbJoyState[i] = true;
		else glbJoyState[i] = false;
	}
	if (lastframe + TICKS_PER_FRAME <= svcGetSystemTick()) glb_newframe = 1;

	touchPosition pos;	
	hidTouchRead(&pos);
	glbStylusX = pos.px;
	glbStylusY = pos.py;
	int x, y;
	hamfake_getstyluspos(x, y);

	glbStylusState = (pos.px>0 || pos.py>0);
}

// Wait for an event to occur.
void
hamfake_awaitEvent()
{
	do {
	    hamfake_pollEvents();
	} while (!hidKeysDown() && !hidKeysUp() && !glb_newframe);
}

bool
hamfake_isPressed(BUTTONS button)
{
    int		bnum;

    hamfake_pollEvents();
//    hamfake_rebuildScreen();

    bnum = getJoyButton(button);
    if (bnum < 0)
	return false;

    return glbJoyState[bnum];
}

int
hamfake_isAnyPressed()
{
  hamfake_pollEvents();
  hamfake_rebuildScreen();

  int			i;
  for (i = 0; i < MAX_JOY_BUTTON; i++)
    if (glbJoyState[i])
      return 0x0;

    if (glbStylusState)
	return 0;

  return 0x3FF;
}

int
hamfake_peekKeyPress()
{
  hamfake_pollEvents();
    return 0;
}

int
hamfake_getKeyPress(bool onlyascii)
{
    return 0;
}

void
hamfake_insertKeyPress(int key)
{
}

void
hamfake_clearKeyboardBuffer()
{
}

void
hamfake_setScrollX(int layer, int scroll)
{
  ham_bg[layer].scrollx = scroll;
}

void
hamfake_setScrollY(int layer, int scroll)
{
  ham_bg[layer].scrolly = scroll;
}

u8 *
convertTo32Bit(const unsigned short *s, int numpixel)
{
  u8 		*result, *d;
  unsigned short	 p;

  result = (u8 *) malloc(numpixel * 4);
  d = result;

  while (numpixel--)
  {
    p = *s++;
    *d++ = (p & 31) * 8 + 4;
    p >>= 5;
    *d++ = (p & 31) * 8 + 4;
    p >>= 5;
    *d++ = (p & 31) * 8 + 4;
    *d++ = 0xff;
  }
  return result;
}

void
ham_Init()
{
  int		i;

  printf("\nPOWDER initializing...\n");

  glbFullScreen = true;

  for (i = 0; i < MAX_SPRITES; i++)
  {
    glbSpriteList[i].active = false;
  }

  memset(glbJoyState, 0, MAX_JOY_BUTTON * sizeof(bool));

  // Load any save games.
  FILE	*fp;

  fp = fopen("/3ds/powder/powder.sav", "rb");
  if (fp)
  {
    fread(glb_rawSRAM, SRAMSIZE, 1, fp);
    fclose(fp);
  }

  // Load any extra tilesets.
  if (bmp_loadExtraTileset())
  {
    ham_extratileset = true;
    printf("External tileset loaded.\n");
  }

	// Initialize the scene
	sceneInit();


  lastframe = svcGetSystemTick();
//  gfxSetScreenFormat(GFX_BOTTOM,GSP_BGR8_OES); //reset screen forma changed by the console


  return;
}

void
ham_StartIntHandler(u8 intno, void (*fp)())
{

}

void
ham_SetBgMode(u8 mode)
{

  if (glb_videomode == -1)
  {
    setResolution(HAM_SCRW * 2, HAM_SCRH * 2);
    rebuildVideoSystemFromGlobals();
  }

  glb_videomode = mode;
}


void
ham_LoadBGPal(void *vpal, int bytes)
{
  // Need to promote our 15bit palette to a 24 bit one.
  int		entries = bytes / 2, i;
  u16		*pal = (u16 *) vpal;

  for (i = 0; i < entries; i++)
  {
    glb_palette[i*4+3] = (pal[i] & 31) << 3;
    glb_palette[i*4+2] = ((pal[i] >> 5) & 31) << 3;
    glb_palette[i*4+1] = ((pal[i] >> 10) & 31) << 3;
    if (i)
      glb_palette[i*4] = 255;
    else
      glb_palette[i*4] = 0;
  }
}

map_info_ptr
ham_InitMapEmptySet(u8 size, u8 )
{
  map_info_ptr		mi;

  mi = new map_info;

  if (size == 0)
  {
    mi->width = 32;
    mi->height = 32;
  }
  else
  {
    mi->width = 64;
    mi->height = 64;
  }

  mi->tiles = new int[mi->width * mi->height];
  memset(mi->tiles, 0, sizeof(int) * mi->width * mi->height);

  return mi;
}

tile_info_ptr
ham_InitTileEmptySet(int entries, int , int)
{
  tile_info_ptr		ti;
  int				i;

  ti = new tile_info;
  ti->numtiles = entries;
  ti->tiles = new u8 *[entries];

  for (i = 0; i < entries; i++)
  {
    ti->tiles[i] = new u8 [8 * 8];
  }
  return ti;
}

void
ham_InitBg(int layer, int foo, int bar, int baz)
{
  ham_bg[layer].scrollx = 0;
  ham_bg[layer].scrolly = 0;
}

void
ham_CreateWin(int , int, int, int, int, int, int, int)
{}

void
ham_DeleteWin(int wid)
{}

void
ham_SetMapTile(int layer, int mx, int my, int tileidx)
{
  map_info_ptr		mi;

  mi = ham_bg[layer].mi;

  mx = (mx % mi->width);
  if (mx < 0)
    mx += mi->width;
  my = (my % mi->height);
  if (my < 0)
    my += mi->height;

  mi->tiles[mx + my * mi->width] = tileidx;

  glb_isdirty = true;
}

void
ham_ReloadTileGfx(tile_info_ptr tiledata, const u16 *data, int destidx,
                  int numtile)
{
  int		 t;
  u8		*raw;
  u8		*dst;

  raw = (u8*) data;
  for (t = destidx; t < destidx + numtile; t++)
  {
    dst = tiledata->tiles[t];

    memcpy(dst, raw, 8*8);
    raw += 8 * 8;
  }
  glb_isdirty = true;
}

void
hamfake_ReloadSpriteGfx(const u16 *data, int tileno, int numtile)
{
  tileno /= 4;
//  UT_ASSERT(tileno >= 0 && tileno < MAX_SPRITES);
  if (tileno < 0 || tileno >= MAX_SPRITES)
    return;
  memcpy(&glbSpriteList[tileno].data, data, numtile * 8 * 8); 
  glb_isdirty = true;
}

void
hamfake_LoadSpritePal(void *vpal, int bytes)
{
  // Need to promote our 15bit palette to a 24 bit one.
  int		entries = bytes / 2, i;
  u16		*pal = (u16 *) vpal;

  for (i = 0; i < entries; i++)
  {
    glb_palette[1024+i*4+3] = (pal[i] & 31) << 3;
    glb_palette[1024+i*4+2] = ((pal[i] >> 5) & 31) << 3;
    glb_palette[1024+i*4+1] = ((pal[i] >> 10) & 31) << 3;
    if (i)
      glb_palette[1024+i*4] = 255;
    else
      glb_palette[1024+i*4] = 0;
  }
  glb_isdirty = true;
}

extern void task_exit();

void hamfake_softReset()
{
  // Deinitialize the scene
  sceneExit();

  // Deinitialize graphics
  C3D_Fini();
  gfxExit();
  task_exit();
  exit(0);
}

bool hamfake_extratileset()
{
  return ham_extratileset;
}

void hamfake_getstyluspos(int &x, int &y)
{
  x = glbStylusX;
  y = glbStylusY;
  // Convert accordint to our scale.
  x -= glbScreenFudgeX;
  y -= glbScreenFudgeY;
  x /= 1.25;//glbScaleFactor;
  y /= 1.25;//glbScaleFactor;
  // After conversion we can be out of the valid bounds.
  if (x < 0)
    x = 0;
  if (y < 0)
    y = 0;
  if (x >= HAM_SCRW)
    x = HAM_SCRW-1;
  if (y >= HAM_SCRH)
    y = HAM_SCRH-1;

  // Now return to the GBA coordinate system by adjusting for the DS coords.
  x -= 8;
  y -= 16;
}

bool
hamfake_getstylusstate()
{
  return glbStylusState;
}

void
hamfake_movesprite(int spriteno, int x, int y)
{
  UT_ASSERT(spriteno >= 0 && spriteno < MAX_SPRITES);
  if (spriteno < 0 || spriteno >= MAX_SPRITES)
    return;
  glb_isdirty = true;
  glbSpriteList[spriteno].x = x;
  glbSpriteList[spriteno].y = y;
}

void
hamfake_enablesprite(int spriteno, bool enabled)
{
  UT_ASSERT(spriteno >= 0 && spriteno < MAX_SPRITES);
  if (spriteno < 0 || spriteno >= MAX_SPRITES)
    return;
  glb_isdirty = true;
  glbSpriteList[spriteno].active = enabled;
}

FILE *
hamfake_fopen(const char *path, const char *mode)
{
char buf[256]; 
  // Use the local directory on these platforms.
  if (path[0]=='/') //3DS trick to know when not reading romfs
	return fopen(path, mode);
  else {
	sprintf(buf,"romfs:/%s",path);
	return fopen(buf, mode);
  }
}

bool
hamfake_fatvalid()
{
    return true;
}

void
hamfake_setTileSize(int width, int height)
{
}

int
hamfake_getKeyModifiers()
{
    return 0;
}
